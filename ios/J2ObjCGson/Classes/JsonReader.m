//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./build/j2objc/java/JsonReader.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "JsonReader.h"
#include "JsonReaderInternalAccess.h"
#include "JsonScope.h"
#include "JsonToken.h"
#include "JsonTreeReader.h"
#include "MalformedJsonException.h"
#include "java/io/EOFException.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/AssertionError.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"

@interface GsonJsonReader () {
 @public
  JavaIoReader *in_;
  jboolean lenient_;
  IOSCharArray *buffer_;
  jint pos_;
  jint limit_;
  jint lineNumber_;
  jint lineStart_;
  jlong peekedLong_;
  jint peekedNumberLength_;
  NSString *peekedString_;
  IOSIntArray *stack_;
  jint stackSize_;
  IOSObjectArray *pathNames_;
  IOSIntArray *pathIndices_;
}

- (jint)peekKeyword;

- (jint)peekNumber;

- (jboolean)isLiteralWithChar:(jchar)c;

- (NSString *)nextQuotedValueWithChar:(jchar)quote;

- (NSString *)nextUnquotedValue;

- (void)skipQuotedValueWithChar:(jchar)quote;

- (void)skipUnquotedValue;

- (void)pushWithInt:(jint)newTop;

- (jboolean)fillBufferWithInt:(jint)minimum;

- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof;

- (void)checkLenient;

- (void)skipToEndOfLine;

- (jboolean)skipToWithNSString:(NSString *)toFind;

- (jchar)readEscapeCharacter;

- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message;

- (void)consumeNonExecutePrefix;

@end

J2OBJC_FIELD_SETTER(GsonJsonReader, in_, JavaIoReader *)
J2OBJC_FIELD_SETTER(GsonJsonReader, buffer_, IOSCharArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, peekedString_, NSString *)
J2OBJC_FIELD_SETTER(GsonJsonReader, stack_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, pathNames_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GsonJsonReader, pathIndices_, IOSIntArray *)

inline IOSCharArray *GsonJsonReader_get_NON_EXECUTE_PREFIX(void);
static IOSCharArray *GsonJsonReader_NON_EXECUTE_PREFIX;
J2OBJC_STATIC_FIELD_OBJ_FINAL(GsonJsonReader, NON_EXECUTE_PREFIX, IOSCharArray *)

inline jlong GsonJsonReader_get_MIN_INCOMPLETE_INTEGER(void);
#define GsonJsonReader_MIN_INCOMPLETE_INTEGER -922337203685477580LL
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, MIN_INCOMPLETE_INTEGER, jlong)

inline jint GsonJsonReader_get_PEEKED_NONE(void);
#define GsonJsonReader_PEEKED_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NONE, jint)

inline jint GsonJsonReader_get_PEEKED_BEGIN_OBJECT(void);
#define GsonJsonReader_PEEKED_BEGIN_OBJECT 1
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BEGIN_OBJECT, jint)

inline jint GsonJsonReader_get_PEEKED_END_OBJECT(void);
#define GsonJsonReader_PEEKED_END_OBJECT 2
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_END_OBJECT, jint)

inline jint GsonJsonReader_get_PEEKED_BEGIN_ARRAY(void);
#define GsonJsonReader_PEEKED_BEGIN_ARRAY 3
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BEGIN_ARRAY, jint)

inline jint GsonJsonReader_get_PEEKED_END_ARRAY(void);
#define GsonJsonReader_PEEKED_END_ARRAY 4
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_END_ARRAY, jint)

inline jint GsonJsonReader_get_PEEKED_TRUE(void);
#define GsonJsonReader_PEEKED_TRUE 5
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_TRUE, jint)

inline jint GsonJsonReader_get_PEEKED_FALSE(void);
#define GsonJsonReader_PEEKED_FALSE 6
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_FALSE, jint)

inline jint GsonJsonReader_get_PEEKED_NULL(void);
#define GsonJsonReader_PEEKED_NULL 7
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NULL, jint)

inline jint GsonJsonReader_get_PEEKED_SINGLE_QUOTED(void);
#define GsonJsonReader_PEEKED_SINGLE_QUOTED 8
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_SINGLE_QUOTED, jint)

inline jint GsonJsonReader_get_PEEKED_DOUBLE_QUOTED(void);
#define GsonJsonReader_PEEKED_DOUBLE_QUOTED 9
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_DOUBLE_QUOTED, jint)

inline jint GsonJsonReader_get_PEEKED_UNQUOTED(void);
#define GsonJsonReader_PEEKED_UNQUOTED 10
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_UNQUOTED, jint)

inline jint GsonJsonReader_get_PEEKED_BUFFERED(void);
#define GsonJsonReader_PEEKED_BUFFERED 11
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_BUFFERED, jint)

inline jint GsonJsonReader_get_PEEKED_SINGLE_QUOTED_NAME(void);
#define GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME 12
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_SINGLE_QUOTED_NAME, jint)

inline jint GsonJsonReader_get_PEEKED_DOUBLE_QUOTED_NAME(void);
#define GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME 13
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_DOUBLE_QUOTED_NAME, jint)

inline jint GsonJsonReader_get_PEEKED_UNQUOTED_NAME(void);
#define GsonJsonReader_PEEKED_UNQUOTED_NAME 14
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_UNQUOTED_NAME, jint)

inline jint GsonJsonReader_get_PEEKED_LONG(void);
#define GsonJsonReader_PEEKED_LONG 15
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_LONG, jint)

inline jint GsonJsonReader_get_PEEKED_NUMBER(void);
#define GsonJsonReader_PEEKED_NUMBER 16
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_NUMBER, jint)

inline jint GsonJsonReader_get_PEEKED_EOF(void);
#define GsonJsonReader_PEEKED_EOF 17
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, PEEKED_EOF, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_NONE(void);
#define GsonJsonReader_NUMBER_CHAR_NONE 0
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_NONE, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_SIGN(void);
#define GsonJsonReader_NUMBER_CHAR_SIGN 1
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_SIGN, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_DIGIT 2
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_DIGIT, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_DECIMAL(void);
#define GsonJsonReader_NUMBER_CHAR_DECIMAL 3
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_DECIMAL, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_FRACTION_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT 4
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_FRACTION_DIGIT, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_E(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_E 5
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_E, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_SIGN(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_SIGN 6
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_SIGN, jint)

inline jint GsonJsonReader_get_NUMBER_CHAR_EXP_DIGIT(void);
#define GsonJsonReader_NUMBER_CHAR_EXP_DIGIT 7
J2OBJC_STATIC_FIELD_CONSTANT(GsonJsonReader, NUMBER_CHAR_EXP_DIGIT, jint)

__attribute__((unused)) static jint GsonJsonReader_peekKeyword(GsonJsonReader *self);

__attribute__((unused)) static jint GsonJsonReader_peekNumber(GsonJsonReader *self);

__attribute__((unused)) static jboolean GsonJsonReader_isLiteralWithChar_(GsonJsonReader *self, jchar c);

__attribute__((unused)) static NSString *GsonJsonReader_nextQuotedValueWithChar_(GsonJsonReader *self, jchar quote);

__attribute__((unused)) static NSString *GsonJsonReader_nextUnquotedValue(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_skipQuotedValueWithChar_(GsonJsonReader *self, jchar quote);

__attribute__((unused)) static void GsonJsonReader_skipUnquotedValue(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_pushWithInt_(GsonJsonReader *self, jint newTop);

__attribute__((unused)) static jboolean GsonJsonReader_fillBufferWithInt_(GsonJsonReader *self, jint minimum);

__attribute__((unused)) static jint GsonJsonReader_nextNonWhitespaceWithBoolean_(GsonJsonReader *self, jboolean throwOnEof);

__attribute__((unused)) static void GsonJsonReader_checkLenient(GsonJsonReader *self);

__attribute__((unused)) static void GsonJsonReader_skipToEndOfLine(GsonJsonReader *self);

__attribute__((unused)) static jboolean GsonJsonReader_skipToWithNSString_(GsonJsonReader *self, NSString *toFind);

__attribute__((unused)) static jchar GsonJsonReader_readEscapeCharacter(GsonJsonReader *self);

__attribute__((unused)) static JavaIoIOException *GsonJsonReader_syntaxErrorWithNSString_(GsonJsonReader *self, NSString *message);

__attribute__((unused)) static void GsonJsonReader_consumeNonExecutePrefix(GsonJsonReader *self);

@interface GsonJsonReader_1 : GsonJsonReaderInternalAccess

- (instancetype)init;

- (void)promoteNameToValueWithGsonJsonReader:(GsonJsonReader *)reader;

@end

J2OBJC_EMPTY_STATIC_INIT(GsonJsonReader_1)

__attribute__((unused)) static void GsonJsonReader_1_init(GsonJsonReader_1 *self);

__attribute__((unused)) static GsonJsonReader_1 *new_GsonJsonReader_1_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static GsonJsonReader_1 *create_GsonJsonReader_1_init(void);

J2OBJC_INITIALIZED_DEFN(GsonJsonReader)

@implementation GsonJsonReader

- (instancetype)initWithJavaIoReader:(JavaIoReader *)inArg {
  GsonJsonReader_initWithJavaIoReader_(self, inArg);
  return self;
}

- (void)setLenientWithBoolean:(jboolean)lenient {
  self->lenient_ = lenient;
}

- (jboolean)isLenient {
  return lenient_;
}

- (void)beginArray {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_BEGIN_ARRAY) {
    GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_ARRAY);
    *IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1) = 0;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_ARRAY but was ", [self peek], [self locationString]));
  }
}

- (void)endArray {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_END_ARRAY) {
    stackSize_--;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_ARRAY but was ", [self peek], [self locationString]));
  }
}

- (void)beginObject {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_BEGIN_OBJECT) {
    GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_OBJECT);
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected BEGIN_OBJECT but was ", [self peek], [self locationString]));
  }
}

- (void)endObject {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_END_OBJECT) {
    stackSize_--;
    (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_, nil);
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected END_OBJECT but was ", [self peek], [self locationString]));
  }
}

- (jboolean)hasNext {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  return p != GsonJsonReader_PEEKED_END_OBJECT && p != GsonJsonReader_PEEKED_END_ARRAY;
}

- (GsonJsonToken *)peek {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  switch (p) {
    case GsonJsonReader_PEEKED_BEGIN_OBJECT:
    return JreLoadEnum(GsonJsonToken, BEGIN_OBJECT);
    case GsonJsonReader_PEEKED_END_OBJECT:
    return JreLoadEnum(GsonJsonToken, END_OBJECT);
    case GsonJsonReader_PEEKED_BEGIN_ARRAY:
    return JreLoadEnum(GsonJsonToken, BEGIN_ARRAY);
    case GsonJsonReader_PEEKED_END_ARRAY:
    return JreLoadEnum(GsonJsonToken, END_ARRAY);
    case GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME:
    case GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME:
    case GsonJsonReader_PEEKED_UNQUOTED_NAME:
    return JreLoadEnum(GsonJsonToken, NAME);
    case GsonJsonReader_PEEKED_TRUE:
    case GsonJsonReader_PEEKED_FALSE:
    return JreLoadEnum(GsonJsonToken, BOOLEAN);
    case GsonJsonReader_PEEKED_NULL:
    return JreLoadEnum(GsonJsonToken, NULL);
    case GsonJsonReader_PEEKED_SINGLE_QUOTED:
    case GsonJsonReader_PEEKED_DOUBLE_QUOTED:
    case GsonJsonReader_PEEKED_UNQUOTED:
    case GsonJsonReader_PEEKED_BUFFERED:
    return JreLoadEnum(GsonJsonToken, STRING);
    case GsonJsonReader_PEEKED_LONG:
    case GsonJsonReader_PEEKED_NUMBER:
    return JreLoadEnum(GsonJsonToken, NUMBER);
    case GsonJsonReader_PEEKED_EOF:
    return JreLoadEnum(GsonJsonToken, END_DOCUMENT);
    default:
    @throw new_JavaLangAssertionError_init();
  }
}

- (jint)doPeek {
  jint peekStack = IOSIntArray_Get(nil_chk(stack_), stackSize_ - 1);
  if (peekStack == GsonJsonScope_EMPTY_ARRAY) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_NONEMPTY_ARRAY;
  }
  else if (peekStack == GsonJsonScope_NONEMPTY_ARRAY) {
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ']':
      return peeked_ = GsonJsonReader_PEEKED_END_ARRAY;
      case ';':
      GsonJsonReader_checkLenient(self);
      case ',':
      break;
      default:
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated array"));
    }
  }
  else if (peekStack == GsonJsonScope_EMPTY_OBJECT || peekStack == GsonJsonScope_NONEMPTY_OBJECT) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_DANGLING_NAME;
    if (peekStack == GsonJsonScope_NONEMPTY_OBJECT) {
      jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
      switch (c) {
        case '}':
        return peeked_ = GsonJsonReader_PEEKED_END_OBJECT;
        case ';':
        GsonJsonReader_checkLenient(self);
        case ',':
        break;
        default:
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated object"));
      }
    }
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case '"':
      return peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME;
      case '\'':
      GsonJsonReader_checkLenient(self);
      return peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME;
      case '}':
      if (peekStack != GsonJsonScope_NONEMPTY_OBJECT) {
        return peeked_ = GsonJsonReader_PEEKED_END_OBJECT;
      }
      else {
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
      default:
      GsonJsonReader_checkLenient(self);
      pos_--;
      if (GsonJsonReader_isLiteralWithChar_(self, (jchar) c)) {
        return peeked_ = GsonJsonReader_PEEKED_UNQUOTED_NAME;
      }
      else {
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected name"));
      }
    }
  }
  else if (peekStack == GsonJsonScope_DANGLING_NAME) {
    *IOSIntArray_GetRef(stack_, stackSize_ - 1) = GsonJsonScope_NONEMPTY_OBJECT;
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
    switch (c) {
      case ':':
      break;
      case '=':
      GsonJsonReader_checkLenient(self);
      if ((pos_ < limit_ || GsonJsonReader_fillBufferWithInt_(self, 1)) && IOSCharArray_Get(nil_chk(buffer_), pos_) == '>') {
        pos_++;
      }
      break;
      default:
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected ':'"));
    }
  }
  else if (peekStack == GsonJsonScope_EMPTY_DOCUMENT) {
    if (lenient_) {
      GsonJsonReader_consumeNonExecutePrefix(self);
    }
    *IOSIntArray_GetRef(nil_chk(stack_), stackSize_ - 1) = GsonJsonScope_NONEMPTY_DOCUMENT;
  }
  else if (peekStack == GsonJsonScope_NONEMPTY_DOCUMENT) {
    jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, false);
    if (c == -1) {
      return peeked_ = GsonJsonReader_PEEKED_EOF;
    }
    else {
      GsonJsonReader_checkLenient(self);
      pos_--;
    }
  }
  else if (peekStack == GsonJsonScope_CLOSED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"JsonReader is closed");
  }
  jint c = GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  switch (c) {
    case ']':
    if (peekStack == GsonJsonScope_EMPTY_ARRAY) {
      return peeked_ = GsonJsonReader_PEEKED_END_ARRAY;
    }
    case ';':
    case ',':
    if (peekStack == GsonJsonScope_EMPTY_ARRAY || peekStack == GsonJsonScope_NONEMPTY_ARRAY) {
      GsonJsonReader_checkLenient(self);
      pos_--;
      return peeked_ = GsonJsonReader_PEEKED_NULL;
    }
    else {
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unexpected value"));
    }
    case '\'':
    GsonJsonReader_checkLenient(self);
    return peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED;
    case '"':
    return peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED;
    case '[':
    return peeked_ = GsonJsonReader_PEEKED_BEGIN_ARRAY;
    case '{':
    return peeked_ = GsonJsonReader_PEEKED_BEGIN_OBJECT;
    default:
    pos_--;
  }
  jint result = GsonJsonReader_peekKeyword(self);
  if (result != GsonJsonReader_PEEKED_NONE) {
    return result;
  }
  result = GsonJsonReader_peekNumber(self);
  if (result != GsonJsonReader_PEEKED_NONE) {
    return result;
  }
  if (!GsonJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(nil_chk(buffer_), pos_))) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Expected value"));
  }
  GsonJsonReader_checkLenient(self);
  return peeked_ = GsonJsonReader_PEEKED_UNQUOTED;
}

- (jint)peekKeyword {
  return GsonJsonReader_peekKeyword(self);
}

- (jint)peekNumber {
  return GsonJsonReader_peekNumber(self);
}

- (jboolean)isLiteralWithChar:(jchar)c {
  return GsonJsonReader_isLiteralWithChar_(self, c);
}

- (NSString *)nextName {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME) {
    result = GsonJsonReader_nextUnquotedValue(self);
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ", [self peek], [self locationString]));
  }
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, result);
  return result;
}

- (NSString *)nextString {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  NSString *result;
  if (p == GsonJsonReader_PEEKED_UNQUOTED) {
    result = GsonJsonReader_nextUnquotedValue(self);
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '\'');
  }
  else if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED) {
    result = GsonJsonReader_nextQuotedValueWithChar_(self, '"');
  }
  else if (p == GsonJsonReader_PEEKED_BUFFERED) {
    result = peekedString_;
    peekedString_ = nil;
  }
  else if (p == GsonJsonReader_PEEKED_LONG) {
    result = JavaLangLong_toStringWithLong_(peekedLong_);
  }
  else if (p == GsonJsonReader_PEEKED_NUMBER) {
    result = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a string but was ", [self peek], [self locationString]));
  }
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (jboolean)nextBoolean {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_TRUE) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return true;
  }
  else if (p == GsonJsonReader_PEEKED_FALSE) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return false;
  }
  @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a boolean but was ", [self peek], [self locationString]));
}

- (void)nextNull {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_NULL) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected null but was ", [self peek], [self locationString]));
  }
}

- (jdouble)nextDouble {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_LONG) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return (jdouble) peekedLong_;
  }
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED) {
    peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
  }
  else if (p == GsonJsonReader_PEEKED_UNQUOTED) {
    peekedString_ = GsonJsonReader_nextUnquotedValue(self);
  }
  else if (p != GsonJsonReader_PEEKED_BUFFERED) {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a double but was ", [self peek], [self locationString]));
  }
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble result = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  if (!lenient_ && (JavaLangDouble_isNaNWithDouble_(result) || JavaLangDouble_isInfiniteWithDouble_(result))) {
    @throw new_GsonMalformedJsonException_initWithNSString_(JreStrcat("$D$", @"JSON forbids NaN and infinities: ", result, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (jlong)nextLong {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  if (p == GsonJsonReader_PEEKED_LONG) {
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return peekedLong_;
  }
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_UNQUOTED) {
    if (p == GsonJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GsonJsonReader_nextUnquotedValue(self);
    }
    else {
      peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      jlong result = JavaLangLong_parseLongWithNSString_(peekedString_);
      peeked_ = GsonJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a long but was ", [self peek], [self locationString]));
  }
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  jlong result = JreFpToLong(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected a long but was ", peekedString_, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (NSString *)nextQuotedValueWithChar:(jchar)quote {
  return GsonJsonReader_nextQuotedValueWithChar_(self, quote);
}

- (NSString *)nextUnquotedValue {
  return GsonJsonReader_nextUnquotedValue(self);
}

- (void)skipQuotedValueWithChar:(jchar)quote {
  GsonJsonReader_skipQuotedValueWithChar_(self, quote);
}

- (void)skipUnquotedValue {
  GsonJsonReader_skipUnquotedValue(self);
}

- (jint)nextInt {
  jint p = peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [self doPeek];
  }
  jint result;
  if (p == GsonJsonReader_PEEKED_LONG) {
    result = (jint) peekedLong_;
    if (peekedLong_ != result) {
      @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$J$", @"Expected an int but was ", peekedLong_, [self locationString]));
    }
    peeked_ = GsonJsonReader_PEEKED_NONE;
    (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
    return result;
  }
  if (p == GsonJsonReader_PEEKED_NUMBER) {
    peekedString_ = [NSString java_stringWithCharacters:buffer_ offset:pos_ length:peekedNumberLength_];
    pos_ += peekedNumberLength_;
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_UNQUOTED) {
    if (p == GsonJsonReader_PEEKED_UNQUOTED) {
      peekedString_ = GsonJsonReader_nextUnquotedValue(self);
    }
    else {
      peekedString_ = GsonJsonReader_nextQuotedValueWithChar_(self, p == GsonJsonReader_PEEKED_SINGLE_QUOTED ? '\'' : '"');
    }
    @try {
      result = JavaLangInteger_parseIntWithNSString_(peekedString_);
      peeked_ = GsonJsonReader_PEEKED_NONE;
      (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
      return result;
    }
    @catch (JavaLangNumberFormatException *ignored) {
    }
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected an int but was ", [self peek], [self locationString]));
  }
  peeked_ = GsonJsonReader_PEEKED_BUFFERED;
  jdouble asDouble = JavaLangDouble_parseDoubleWithNSString_(peekedString_);
  result = JreFpToInt(asDouble);
  if (result != asDouble) {
    @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$$", @"Expected an int but was ", peekedString_, [self locationString]));
  }
  peekedString_ = nil;
  peeked_ = GsonJsonReader_PEEKED_NONE;
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  return result;
}

- (void)close {
  peeked_ = GsonJsonReader_PEEKED_NONE;
  *IOSIntArray_GetRef(nil_chk(stack_), 0) = GsonJsonScope_CLOSED;
  stackSize_ = 1;
  [((JavaIoReader *) nil_chk(in_)) close];
}

- (void)skipValue {
  jint count = 0;
  do {
    jint p = peeked_;
    if (p == GsonJsonReader_PEEKED_NONE) {
      p = [self doPeek];
    }
    if (p == GsonJsonReader_PEEKED_BEGIN_ARRAY) {
      GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_ARRAY);
      count++;
    }
    else if (p == GsonJsonReader_PEEKED_BEGIN_OBJECT) {
      GsonJsonReader_pushWithInt_(self, GsonJsonScope_EMPTY_OBJECT);
      count++;
    }
    else if (p == GsonJsonReader_PEEKED_END_ARRAY) {
      stackSize_--;
      count--;
    }
    else if (p == GsonJsonReader_PEEKED_END_OBJECT) {
      stackSize_--;
      count--;
    }
    else if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME || p == GsonJsonReader_PEEKED_UNQUOTED) {
      GsonJsonReader_skipUnquotedValue(self);
    }
    else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED || p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
      GsonJsonReader_skipQuotedValueWithChar_(self, '\'');
    }
    else if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED || p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
      GsonJsonReader_skipQuotedValueWithChar_(self, '"');
    }
    else if (p == GsonJsonReader_PEEKED_NUMBER) {
      pos_ += peekedNumberLength_;
    }
    peeked_ = GsonJsonReader_PEEKED_NONE;
  }
  while (count != 0);
  (*IOSIntArray_GetRef(nil_chk(pathIndices_), stackSize_ - 1))++;
  (void) IOSObjectArray_Set(nil_chk(pathNames_), stackSize_ - 1, @"null");
}

- (void)pushWithInt:(jint)newTop {
  GsonJsonReader_pushWithInt_(self, newTop);
}

- (jboolean)fillBufferWithInt:(jint)minimum {
  return GsonJsonReader_fillBufferWithInt_(self, minimum);
}

- (jint)nextNonWhitespaceWithBoolean:(jboolean)throwOnEof {
  return GsonJsonReader_nextNonWhitespaceWithBoolean_(self, throwOnEof);
}

- (void)checkLenient {
  GsonJsonReader_checkLenient(self);
}

- (void)skipToEndOfLine {
  GsonJsonReader_skipToEndOfLine(self);
}

- (jboolean)skipToWithNSString:(NSString *)toFind {
  return GsonJsonReader_skipToWithNSString_(self, toFind);
}

- (NSString *)description {
  return JreStrcat("$$", [[self java_getClass] getSimpleName], [self locationString]);
}

- (NSString *)locationString {
  jint line = lineNumber_ + 1;
  jint column = pos_ - lineStart_ + 1;
  return JreStrcat("$I$I$$", @" at line ", line, @" column ", column, @" path ", [self getPath]);
}

- (NSString *)getPath {
  JavaLangStringBuilder *result = [new_JavaLangStringBuilder_init() appendWithChar:'$'];
  for (jint i = 0, size = stackSize_; i < size; i++) {
    switch (IOSIntArray_Get(nil_chk(stack_), i)) {
      case GsonJsonScope_EMPTY_ARRAY:
      case GsonJsonScope_NONEMPTY_ARRAY:
      (void) [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'['])) appendWithInt:IOSIntArray_Get(nil_chk(pathIndices_), i)])) appendWithChar:']'];
      break;
      case GsonJsonScope_EMPTY_OBJECT:
      case GsonJsonScope_DANGLING_NAME:
      case GsonJsonScope_NONEMPTY_OBJECT:
      (void) [((JavaLangStringBuilder *) nil_chk(result)) appendWithChar:'.'];
      if (IOSObjectArray_Get(nil_chk(pathNames_), i) != nil) {
        (void) [result appendWithNSString:IOSObjectArray_Get(pathNames_, i)];
      }
      break;
      case GsonJsonScope_NONEMPTY_DOCUMENT:
      case GsonJsonScope_EMPTY_DOCUMENT:
      case GsonJsonScope_CLOSED:
      break;
    }
  }
  return [((JavaLangStringBuilder *) nil_chk(result)) description];
}

- (jchar)readEscapeCharacter {
  return GsonJsonReader_readEscapeCharacter(self);
}

- (JavaIoIOException *)syntaxErrorWithNSString:(NSString *)message {
  return GsonJsonReader_syntaxErrorWithNSString_(self, message);
}

- (void)consumeNonExecutePrefix {
  GsonJsonReader_consumeNonExecutePrefix(self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x11, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x11, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LGsonJsonToken;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x0, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 4, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "D", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, 6, 5, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 7, 5, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 10, 9, 3, -1, -1, -1 },
    { NULL, "I", 0x2, 11, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "Z", 0x2, 12, 13, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 14, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "C", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "LJavaIoIOException;", 0x2, 15, 13, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoReader:);
  methods[1].selector = @selector(setLenientWithBoolean:);
  methods[2].selector = @selector(isLenient);
  methods[3].selector = @selector(beginArray);
  methods[4].selector = @selector(endArray);
  methods[5].selector = @selector(beginObject);
  methods[6].selector = @selector(endObject);
  methods[7].selector = @selector(hasNext);
  methods[8].selector = @selector(peek);
  methods[9].selector = @selector(doPeek);
  methods[10].selector = @selector(peekKeyword);
  methods[11].selector = @selector(peekNumber);
  methods[12].selector = @selector(isLiteralWithChar:);
  methods[13].selector = @selector(nextName);
  methods[14].selector = @selector(nextString);
  methods[15].selector = @selector(nextBoolean);
  methods[16].selector = @selector(nextNull);
  methods[17].selector = @selector(nextDouble);
  methods[18].selector = @selector(nextLong);
  methods[19].selector = @selector(nextQuotedValueWithChar:);
  methods[20].selector = @selector(nextUnquotedValue);
  methods[21].selector = @selector(skipQuotedValueWithChar:);
  methods[22].selector = @selector(skipUnquotedValue);
  methods[23].selector = @selector(nextInt);
  methods[24].selector = @selector(close);
  methods[25].selector = @selector(skipValue);
  methods[26].selector = @selector(pushWithInt:);
  methods[27].selector = @selector(fillBufferWithInt:);
  methods[28].selector = @selector(nextNonWhitespaceWithBoolean:);
  methods[29].selector = @selector(checkLenient);
  methods[30].selector = @selector(skipToEndOfLine);
  methods[31].selector = @selector(skipToWithNSString:);
  methods[32].selector = @selector(description);
  methods[33].selector = @selector(locationString);
  methods[34].selector = @selector(getPath);
  methods[35].selector = @selector(readEscapeCharacter);
  methods[36].selector = @selector(syntaxErrorWithNSString:);
  methods[37].selector = @selector(consumeNonExecutePrefix);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NON_EXECUTE_PREFIX", "[C", .constantValue.asLong = 0, 0x1a, -1, 16, -1, -1 },
    { "MIN_INCOMPLETE_INTEGER", "J", .constantValue.asLong = GsonJsonReader_MIN_INCOMPLETE_INTEGER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NONE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NONE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_OBJECT", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BEGIN_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_OBJECT", "I", .constantValue.asInt = GsonJsonReader_PEEKED_END_OBJECT, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BEGIN_ARRAY", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BEGIN_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_END_ARRAY", "I", .constantValue.asInt = GsonJsonReader_PEEKED_END_ARRAY, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_TRUE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_TRUE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_FALSE", "I", .constantValue.asInt = GsonJsonReader_PEEKED_FALSE, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NULL", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NULL, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_SINGLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_DOUBLE_QUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_UNQUOTED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_BUFFERED", "I", .constantValue.asInt = GsonJsonReader_PEEKED_BUFFERED, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_SINGLE_QUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_DOUBLE_QUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_UNQUOTED_NAME", "I", .constantValue.asInt = GsonJsonReader_PEEKED_UNQUOTED_NAME, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_LONG", "I", .constantValue.asInt = GsonJsonReader_PEEKED_LONG, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_NUMBER", "I", .constantValue.asInt = GsonJsonReader_PEEKED_NUMBER, 0x1a, -1, -1, -1, -1 },
    { "PEEKED_EOF", "I", .constantValue.asInt = GsonJsonReader_PEEKED_EOF, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_NONE", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_NONE, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_SIGN", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_DECIMAL", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_DECIMAL, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_FRACTION_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_E", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_E, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_SIGN", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NUMBER_CHAR_EXP_DIGIT", "I", .constantValue.asInt = GsonJsonReader_NUMBER_CHAR_EXP_DIGIT, 0x1a, -1, -1, -1, -1 },
    { "in_", "LJavaIoReader;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lenient_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[C", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "limit_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineNumber_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineStart_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peeked_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "peekedLong_", "J", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedNumberLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "peekedString_", "LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stack_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stackSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathNames_", "[LNSString;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "pathIndices_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoReader;", "setLenient", "Z", "LJavaIoIOException;", "isLiteral", "C", "nextQuotedValue", "skipQuotedValue", "push", "I", "fillBuffer", "nextNonWhitespace", "skipTo", "LNSString;", "toString", "syntaxError", &GsonJsonReader_NON_EXECUTE_PREFIX };
  static const J2ObjcClassInfo _GsonJsonReader = { "JsonReader", "com.google.gson.stream", ptrTable, methods, fields, 7, 0x1, 38, 43, -1, -1, -1, -1, -1 };
  return &_GsonJsonReader;
}

+ (void)initialize {
  if (self == [GsonJsonReader class]) {
    GsonJsonReader_NON_EXECUTE_PREFIX = [@")]}'\n" java_toCharArray];
    {
      *JreLoadStaticRef(GsonJsonReaderInternalAccess, INSTANCE) = new_GsonJsonReader_1_init();
    }
    J2OBJC_SET_INITIALIZED(GsonJsonReader)
  }
}

@end

void GsonJsonReader_initWithJavaIoReader_(GsonJsonReader *self, JavaIoReader *inArg) {
  NSObject_init(self);
  self->lenient_ = false;
  self->buffer_ = [IOSCharArray newArrayWithLength:1024];
  self->pos_ = 0;
  self->limit_ = 0;
  self->lineNumber_ = 0;
  self->lineStart_ = 0;
  self->peeked_ = GsonJsonReader_PEEKED_NONE;
  self->stack_ = [IOSIntArray newArrayWithLength:32];
  self->stackSize_ = 0;
  {
    *IOSIntArray_GetRef(self->stack_, self->stackSize_++) = GsonJsonScope_EMPTY_DOCUMENT;
  }
  self->pathNames_ = [IOSObjectArray newArrayWithLength:32 type:NSString_class_()];
  self->pathIndices_ = [IOSIntArray newArrayWithLength:32];
  if (inArg == nil) {
    @throw new_JavaLangNullPointerException_initWithNSString_(@"in == null");
  }
  self->in_ = inArg;
}

GsonJsonReader *new_GsonJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_NEW_IMPL(GsonJsonReader, initWithJavaIoReader_, inArg)
}

GsonJsonReader *create_GsonJsonReader_initWithJavaIoReader_(JavaIoReader *inArg) {
  J2OBJC_CREATE_IMPL(GsonJsonReader, initWithJavaIoReader_, inArg)
}

jint GsonJsonReader_peekKeyword(GsonJsonReader *self) {
  jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_);
  NSString *keyword;
  NSString *keywordUpper;
  jint peeking;
  if (c == 't' || c == 'T') {
    keyword = @"true";
    keywordUpper = @"TRUE";
    peeking = GsonJsonReader_PEEKED_TRUE;
  }
  else if (c == 'f' || c == 'F') {
    keyword = @"false";
    keywordUpper = @"FALSE";
    peeking = GsonJsonReader_PEEKED_FALSE;
  }
  else if (c == 'n' || c == 'N') {
    keyword = @"null";
    keywordUpper = @"NULL";
    peeking = GsonJsonReader_PEEKED_NULL;
  }
  else {
    return GsonJsonReader_PEEKED_NONE;
  }
  jint length = [keyword java_length];
  for (jint i = 1; i < length; i++) {
    if (self->pos_ + i >= self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
      return GsonJsonReader_PEEKED_NONE;
    }
    c = IOSCharArray_Get(self->buffer_, self->pos_ + i);
    if (c != [keyword charAtWithInt:i] && c != [keywordUpper charAtWithInt:i]) {
      return GsonJsonReader_PEEKED_NONE;
    }
  }
  if ((self->pos_ + length < self->limit_ || GsonJsonReader_fillBufferWithInt_(self, length + 1)) && GsonJsonReader_isLiteralWithChar_(self, IOSCharArray_Get(self->buffer_, self->pos_ + length))) {
    return GsonJsonReader_PEEKED_NONE;
  }
  self->pos_ += length;
  return self->peeked_ = peeking;
}

jint GsonJsonReader_peekNumber(GsonJsonReader *self) {
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  jlong value = 0;
  jboolean negative = false;
  jboolean fitsInLong = true;
  jint last = GsonJsonReader_NUMBER_CHAR_NONE;
  jint i = 0;
  for (; true; i++) {
    if (p + i == l) {
      if (i == ((IOSCharArray *) nil_chk(buffer))->size_) {
        return GsonJsonReader_PEEKED_NONE;
      }
      if (!GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    jchar c = IOSCharArray_Get(nil_chk(buffer), p + i);
    switch (c) {
      case '-':
      if (last == GsonJsonReader_NUMBER_CHAR_NONE) {
        negative = true;
        last = GsonJsonReader_NUMBER_CHAR_SIGN;
        continue;
      }
      else if (last == GsonJsonReader_NUMBER_CHAR_EXP_E) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      case '+':
      if (last == GsonJsonReader_NUMBER_CHAR_EXP_E) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_SIGN;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      case 'e':
      case 'E':
      if (last == GsonJsonReader_NUMBER_CHAR_DIGIT || last == GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_E;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      case '.':
      if (last == GsonJsonReader_NUMBER_CHAR_DIGIT) {
        last = GsonJsonReader_NUMBER_CHAR_DECIMAL;
        continue;
      }
      return GsonJsonReader_PEEKED_NONE;
      default:
      if (c < '0' || c > '9') {
        if (!GsonJsonReader_isLiteralWithChar_(self, c)) {
          goto break_charactersOfNumber;
        }
        return GsonJsonReader_PEEKED_NONE;
      }
      if (last == GsonJsonReader_NUMBER_CHAR_SIGN || last == GsonJsonReader_NUMBER_CHAR_NONE) {
        value = -(c - '0');
        last = GsonJsonReader_NUMBER_CHAR_DIGIT;
      }
      else if (last == GsonJsonReader_NUMBER_CHAR_DIGIT) {
        if (value == 0) {
          return GsonJsonReader_PEEKED_NONE;
        }
        jlong newValue = value * 10 - (c - '0');
        fitsInLong &= (value > GsonJsonReader_MIN_INCOMPLETE_INTEGER || (value == GsonJsonReader_MIN_INCOMPLETE_INTEGER && newValue < value));
        value = newValue;
      }
      else if (last == GsonJsonReader_NUMBER_CHAR_DECIMAL) {
        last = GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT;
      }
      else if (last == GsonJsonReader_NUMBER_CHAR_EXP_E || last == GsonJsonReader_NUMBER_CHAR_EXP_SIGN) {
        last = GsonJsonReader_NUMBER_CHAR_EXP_DIGIT;
      }
    }
  }
  break_charactersOfNumber: ;
  if (last == GsonJsonReader_NUMBER_CHAR_DIGIT && fitsInLong && (value != JavaLangLong_MIN_VALUE || negative) && (value != 0 || false == negative)) {
    self->peekedLong_ = negative ? value : -value;
    self->pos_ += i;
    return self->peeked_ = GsonJsonReader_PEEKED_LONG;
  }
  else if (last == GsonJsonReader_NUMBER_CHAR_DIGIT || last == GsonJsonReader_NUMBER_CHAR_FRACTION_DIGIT || last == GsonJsonReader_NUMBER_CHAR_EXP_DIGIT) {
    self->peekedNumberLength_ = i;
    return self->peeked_ = GsonJsonReader_PEEKED_NUMBER;
  }
  else {
    return GsonJsonReader_PEEKED_NONE;
  }
}

jboolean GsonJsonReader_isLiteralWithChar_(GsonJsonReader *self, jchar c) {
  switch (c) {
    case '/':
    case '\\':
    case ';':
    case '#':
    case '=':
    GsonJsonReader_checkLenient(self);
    case '{':
    case '}':
    case '[':
    case ']':
    case ':':
    case ',':
    case ' ':
    case 0x0009:
    case 0x000c:
    case 0x000d:
    case 0x000a:
    return false;
    default:
    return true;
  }
}

NSString *GsonJsonReader_nextQuotedValueWithChar_(GsonJsonReader *self, jchar quote) {
  IOSCharArray *buffer = self->buffer_;
  JavaLangStringBuilder *builder = nil;
  while (true) {
    jint p = self->pos_;
    jint l = self->limit_;
    jint start = p;
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      if (c == quote) {
        self->pos_ = p;
        jint len = p - start - 1;
        if (builder == nil) {
          return [NSString java_stringWithCharacters:buffer offset:start length:len];
        }
        else {
          (void) [builder appendWithCharArray:buffer withInt:start withInt:len];
          return [builder description];
        }
      }
      else if (c == '\\') {
        self->pos_ = p;
        jint len = p - start - 1;
        if (builder == nil) {
          jint estimatedLength = (len + 1) * 2;
          builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(estimatedLength, 16));
        }
        (void) [builder appendWithCharArray:buffer withInt:start withInt:len];
        (void) [builder appendWithChar:GsonJsonReader_readEscapeCharacter(self)];
        p = self->pos_;
        l = self->limit_;
        start = p;
      }
      else if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    if (builder == nil) {
      jint estimatedLength = (p - start) * 2;
      builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(estimatedLength, 16));
    }
    (void) [builder appendWithCharArray:buffer withInt:start withInt:p - start];
    self->pos_ = p;
    if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
    }
  }
}

NSString *GsonJsonReader_nextUnquotedValue(GsonJsonReader *self) {
  JavaLangStringBuilder *builder = nil;
  jint i = 0;
  while (true) {
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GsonJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        goto break_findNonLiteralCharacter;
      }
    }
    if (i < ((IOSCharArray *) nil_chk(self->buffer_))->size_) {
      if (GsonJsonReader_fillBufferWithInt_(self, i + 1)) {
        continue;
      }
      else {
        break;
      }
    }
    if (builder == nil) {
      builder = new_JavaLangStringBuilder_initWithInt_(JavaLangMath_maxWithInt_withInt_(i, 16));
    }
    (void) [builder appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i];
    self->pos_ += i;
    i = 0;
    if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
      break;
    }
  }
  break_findNonLiteralCharacter: ;
  NSString *result = (nil == builder) ? [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:i] : [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk(builder)) appendWithCharArray:self->buffer_ withInt:self->pos_ withInt:i])) description];
  self->pos_ += i;
  return result;
}

void GsonJsonReader_skipQuotedValueWithChar_(GsonJsonReader *self, jchar quote) {
  IOSCharArray *buffer = self->buffer_;
  do {
    jint p = self->pos_;
    jint l = self->limit_;
    while (p < l) {
      jint c = IOSCharArray_Get(nil_chk(buffer), p++);
      if (c == quote) {
        self->pos_ = p;
        return;
      }
      else if (c == '\\') {
        self->pos_ = p;
        GsonJsonReader_readEscapeCharacter(self);
        p = self->pos_;
        l = self->limit_;
      }
      else if (c == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = p;
      }
    }
    self->pos_ = p;
  }
  while (GsonJsonReader_fillBufferWithInt_(self, 1));
  @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated string"));
}

void GsonJsonReader_skipUnquotedValue(GsonJsonReader *self) {
  do {
    jint i = 0;
    for (; self->pos_ + i < self->limit_; i++) {
      switch (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i)) {
        case '/':
        case '\\':
        case ';':
        case '#':
        case '=':
        GsonJsonReader_checkLenient(self);
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case ',':
        case ' ':
        case 0x0009:
        case 0x000c:
        case 0x000d:
        case 0x000a:
        self->pos_ += i;
        return;
      }
    }
    self->pos_ += i;
  }
  while (GsonJsonReader_fillBufferWithInt_(self, 1));
}

void GsonJsonReader_pushWithInt_(GsonJsonReader *self, jint newTop) {
  if (self->stackSize_ == ((IOSIntArray *) nil_chk(self->stack_))->size_) {
    IOSIntArray *newStack = [IOSIntArray newArrayWithLength:self->stackSize_ * 2];
    IOSIntArray *newPathIndices = [IOSIntArray newArrayWithLength:self->stackSize_ * 2];
    IOSObjectArray *newPathNames = [IOSObjectArray newArrayWithLength:self->stackSize_ * 2 type:NSString_class_()];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->stack_, 0, newStack, 0, self->stackSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pathIndices_, 0, newPathIndices, 0, self->stackSize_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pathNames_, 0, newPathNames, 0, self->stackSize_);
    self->stack_ = newStack;
    self->pathIndices_ = newPathIndices;
    self->pathNames_ = newPathNames;
  }
  *IOSIntArray_GetRef(self->stack_, self->stackSize_++) = newTop;
}

jboolean GsonJsonReader_fillBufferWithInt_(GsonJsonReader *self, jint minimum) {
  IOSCharArray *buffer = self->buffer_;
  self->lineStart_ -= self->pos_;
  if (self->limit_ != self->pos_) {
    self->limit_ -= self->pos_;
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, self->pos_, buffer, 0, self->limit_);
  }
  else {
    self->limit_ = 0;
  }
  self->pos_ = 0;
  jint total;
  while ((total = [((JavaIoReader *) nil_chk(self->in_)) readWithCharArray:buffer withInt:self->limit_ withInt:((IOSCharArray *) nil_chk(buffer))->size_ - self->limit_]) != -1) {
    self->limit_ += total;
    if (self->lineNumber_ == 0 && self->lineStart_ == 0 && self->limit_ > 0 && IOSCharArray_Get(buffer, 0) == 0xfeff) {
      self->pos_++;
      self->lineStart_++;
      minimum++;
    }
    if (self->limit_ >= minimum) {
      return true;
    }
  }
  return false;
}

jint GsonJsonReader_nextNonWhitespaceWithBoolean_(GsonJsonReader *self, jboolean throwOnEof) {
  IOSCharArray *buffer = self->buffer_;
  jint p = self->pos_;
  jint l = self->limit_;
  while (true) {
    if (p == l) {
      self->pos_ = p;
      if (!GsonJsonReader_fillBufferWithInt_(self, 1)) {
        break;
      }
      p = self->pos_;
      l = self->limit_;
    }
    jint c = IOSCharArray_Get(nil_chk(buffer), p++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = p;
      continue;
    }
    else if (c == ' ' || c == 0x000d || c == 0x0009) {
      continue;
    }
    if (c == '/') {
      self->pos_ = p;
      if (p == l) {
        self->pos_--;
        jboolean charsLoaded = GsonJsonReader_fillBufferWithInt_(self, 2);
        self->pos_++;
        if (!charsLoaded) {
          return c;
        }
      }
      GsonJsonReader_checkLenient(self);
      jchar peek = IOSCharArray_Get(buffer, self->pos_);
      switch (peek) {
        case '*':
        self->pos_++;
        if (!GsonJsonReader_skipToWithNSString_(self, @"*/")) {
          @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated comment"));
        }
        p = self->pos_ + 2;
        l = self->limit_;
        continue;
        case '/':
        self->pos_++;
        GsonJsonReader_skipToEndOfLine(self);
        p = self->pos_;
        l = self->limit_;
        continue;
        default:
        return c;
      }
    }
    else if (c == '#') {
      self->pos_ = p;
      GsonJsonReader_checkLenient(self);
      GsonJsonReader_skipToEndOfLine(self);
      p = self->pos_;
      l = self->limit_;
    }
    else {
      self->pos_ = p;
      return c;
    }
  }
  if (throwOnEof) {
    @throw new_JavaIoEOFException_initWithNSString_(JreStrcat("$$", @"End of input", [self locationString]));
  }
  else {
    return -1;
  }
}

void GsonJsonReader_checkLenient(GsonJsonReader *self) {
  if (!self->lenient_) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Use JsonReader.setLenient(true) to accept malformed JSON"));
  }
}

void GsonJsonReader_skipToEndOfLine(GsonJsonReader *self) {
  while (self->pos_ < self->limit_ || GsonJsonReader_fillBufferWithInt_(self, 1)) {
    jchar c = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
    if (c == 0x000a) {
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      break;
    }
    else if (c == 0x000d) {
      break;
    }
  }
}

jboolean GsonJsonReader_skipToWithNSString_(GsonJsonReader *self, NSString *toFind) {
  jint length = [((NSString *) nil_chk(toFind)) java_length];
  for (; self->pos_ + length <= self->limit_ || GsonJsonReader_fillBufferWithInt_(self, length); self->pos_++) {
    {
      if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_) == 0x000a) {
        self->lineNumber_++;
        self->lineStart_ = self->pos_ + 1;
        continue;
      }
      for (jint c = 0; c < length; c++) {
        if (IOSCharArray_Get(self->buffer_, self->pos_ + c) != [toFind charAtWithInt:c]) {
          goto continue_outer;
        }
      }
      return true;
    }
    continue_outer: ;
  }
  return false;
}

jchar GsonJsonReader_readEscapeCharacter(GsonJsonReader *self) {
  if (self->pos_ == self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, 1)) {
    @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
  }
  jchar escaped = IOSCharArray_Get(nil_chk(self->buffer_), self->pos_++);
  {
    jchar result;
    switch (escaped) {
      case 'u':
      if (self->pos_ + 4 > self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, 4)) {
        @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Unterminated escape sequence"));
      }
      result = 0;
      for (jint i = self->pos_, end = i + 4; i < end; i++) {
        jchar c = IOSCharArray_Get(self->buffer_, i);
        JreLShiftAssignChar(&result, 4);
        if (c >= '0' && c <= '9') {
          result += (c - '0');
        }
        else if (c >= 'a' && c <= 'f') {
          result += (c - 'a' + 10);
        }
        else if (c >= 'A' && c <= 'F') {
          result += (c - 'A' + 10);
        }
        else {
          @throw new_JavaLangNumberFormatException_initWithNSString_(JreStrcat("$$", @"\\u", [NSString java_stringWithCharacters:self->buffer_ offset:self->pos_ length:4]));
        }
      }
      self->pos_ += 4;
      return result;
      case 't':
      return 0x0009;
      case 'b':
      return 0x0008;
      case 'n':
      return 0x000a;
      case 'r':
      return 0x000d;
      case 'f':
      return 0x000c;
      case 0x000a:
      self->lineNumber_++;
      self->lineStart_ = self->pos_;
      case '\'':
      case '"':
      case '\\':
      case '/':
      return escaped;
      default:
      @throw nil_chk(GsonJsonReader_syntaxErrorWithNSString_(self, @"Invalid escape sequence"));
    }
  }
}

JavaIoIOException *GsonJsonReader_syntaxErrorWithNSString_(GsonJsonReader *self, NSString *message) {
  @throw new_GsonMalformedJsonException_initWithNSString_(JreStrcat("$$", message, [self locationString]));
}

void GsonJsonReader_consumeNonExecutePrefix(GsonJsonReader *self) {
  GsonJsonReader_nextNonWhitespaceWithBoolean_(self, true);
  self->pos_--;
  if (self->pos_ + ((IOSCharArray *) nil_chk(GsonJsonReader_NON_EXECUTE_PREFIX))->size_ > self->limit_ && !GsonJsonReader_fillBufferWithInt_(self, GsonJsonReader_NON_EXECUTE_PREFIX->size_)) {
    return;
  }
  for (jint i = 0; i < GsonJsonReader_NON_EXECUTE_PREFIX->size_; i++) {
    if (IOSCharArray_Get(nil_chk(self->buffer_), self->pos_ + i) != IOSCharArray_Get(GsonJsonReader_NON_EXECUTE_PREFIX, i)) {
      return;
    }
  }
  self->pos_ += GsonJsonReader_NON_EXECUTE_PREFIX->size_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GsonJsonReader)

J2OBJC_NAME_MAPPING(GsonJsonReader, "com.google.gson.stream", "Gson")

@implementation GsonJsonReader_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  GsonJsonReader_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)promoteNameToValueWithGsonJsonReader:(GsonJsonReader *)reader {
  if ([reader isKindOfClass:[GsonJsonTreeReader class]]) {
    [((GsonJsonTreeReader *) nil_chk(((GsonJsonTreeReader *) cast_chk(reader, [GsonJsonTreeReader class])))) promoteNameToValue];
    return;
  }
  jint p = ((GsonJsonReader *) nil_chk(reader))->peeked_;
  if (p == GsonJsonReader_PEEKED_NONE) {
    p = [reader doPeek];
  }
  if (p == GsonJsonReader_PEEKED_DOUBLE_QUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_DOUBLE_QUOTED;
  }
  else if (p == GsonJsonReader_PEEKED_SINGLE_QUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_SINGLE_QUOTED;
  }
  else if (p == GsonJsonReader_PEEKED_UNQUOTED_NAME) {
    reader->peeked_ = GsonJsonReader_PEEKED_UNQUOTED;
  }
  else {
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$@$", @"Expected a name but was ", [reader peek], [reader locationString]));
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(promoteNameToValueWithGsonJsonReader:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "promoteNameToValue", "LGsonJsonReader;", "LJavaIoIOException;" };
  static const J2ObjcClassInfo _GsonJsonReader_1 = { "", "com.google.gson.stream", ptrTable, methods, NULL, 7, 0x8018, 2, 0, 1, -1, -1, -1, -1 };
  return &_GsonJsonReader_1;
}

@end

void GsonJsonReader_1_init(GsonJsonReader_1 *self) {
  GsonJsonReaderInternalAccess_init(self);
}

GsonJsonReader_1 *new_GsonJsonReader_1_init() {
  J2OBJC_NEW_IMPL(GsonJsonReader_1, init)
}

GsonJsonReader_1 *create_GsonJsonReader_1_init() {
  J2OBJC_CREATE_IMPL(GsonJsonReader_1, init)
}
